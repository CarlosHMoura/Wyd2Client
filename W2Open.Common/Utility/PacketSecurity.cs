using System;

namespace WYD2.Common.Utility
{
    /// <summary>
    /// Implements the security protocol used in the game client.
    /// </summary>
    public static class PacketSecurity
    {
        private static Int32 m_LastPacket;
        private static Int32 m_TimePacket;

        /// <summary>
        /// The keys used in the enc/dec process.
        /// </summary>
        private static byte[] KeyTable = new byte[512]
        {
	        #region Keys
		    0x84, 0x87, 0x37, 0xD7, 0xEA, 0x79, 0x91, 0x7D, 0x4B, 0x4B, 0x85, 0x7D, 0x87, 0x81, 0x91, 0x7C, 0x0F, 0x73, 0x91, 0x91, 0x87, 0x7D, 0x0D, 0x7D, 0x86, 0x8F, 0x73, 0x0F, 0xE1, 0xDD, 0x85, 0x7D,
    0x05, 0x7D, 0x85, 0x83, 0x87, 0x9C, 0x85, 0x33, 0x0D, 0xE2, 0x87, 0x19, 0x0F, 0x79, 0x85, 0x86, 0x37, 0x7D, 0xD7, 0xDD, 0xE9, 0x7D, 0xD7, 0x7D, 0x85, 0x79, 0x05, 0x7D, 0x0F, 0xE1, 0x87, 0x7E,
    0x23, 0x87, 0xF5, 0x79, 0x5F, 0xE3, 0x4B, 0x83, 0xA3, 0xA2, 0xAE, 0x0E, 0x14, 0x7D, 0xDE, 0x7E, 0x85, 0x7A, 0x85, 0xAF, 0xCD, 0x7D, 0x87, 0xA5, 0x87, 0x7D, 0xE1, 0x7D, 0x88, 0x7D, 0x15, 0x91,
    0x23, 0x7D, 0x87, 0x7C, 0x0D, 0x7A, 0x85, 0x87, 0x17, 0x7C, 0x85, 0x7D, 0xAC, 0x80, 0xBB, 0x79, 0x84, 0x9B, 0x5B, 0xA5, 0xD7, 0x8F, 0x05, 0x0F, 0x85, 0x7E, 0x85, 0x80, 0x85, 0x98, 0xF5, 0x9D,
    0xA3, 0x1A, 0x0D, 0x19, 0x87, 0x7C, 0x85, 0x7D, 0x84, 0x7D, 0x85, 0x7E, 0xE7, 0x97, 0x0D, 0x0F, 0x85, 0x7B, 0xEA, 0x7D, 0xAD, 0x80, 0xAD, 0x7D, 0xB7, 0xAF, 0x0D, 0x7D, 0xE9, 0x3D, 0x85, 0x7D,
    0x87, 0xB7, 0x23, 0x7D, 0xE7, 0xB7, 0xA3, 0x0C, 0x87, 0x7E, 0x85, 0xA5, 0x7D, 0x76, 0x35, 0xB9, 0x0D, 0x6F, 0x23, 0x7D, 0x87, 0x9B, 0x85, 0x0C, 0xE1, 0xA1, 0x0D, 0x7F, 0x87, 0x7D, 0x84, 0x7A,
    0x84, 0x7B, 0xE1, 0x86, 0xE8, 0x6F, 0xD1, 0x79, 0x85, 0x19, 0x53, 0x95, 0xC3, 0x47, 0x19, 0x7D, 0xE7, 0x0C, 0x37, 0x7C, 0x23, 0x7D, 0x85, 0x7D, 0x4B, 0x79, 0x21, 0xA5, 0x87, 0x7D, 0x19, 0x7D,
    0x0D, 0x7D, 0x15, 0x91, 0x23, 0x7D, 0x87, 0x7C, 0x85, 0x7A, 0x85, 0xAF, 0xCD, 0x7D, 0x87, 0x7D, 0xE9, 0x3D, 0x85, 0x7D, 0x15, 0x79, 0x85, 0x7D, 0xC1, 0x7B, 0xEA, 0x7D, 0xB7, 0x7D, 0x85, 0x7D,
    0x85, 0x7D, 0x0D, 0x7D, 0xE9, 0x73, 0x85, 0x79, 0x05, 0x7D, 0xD7, 0x7D, 0x85, 0xE1, 0xB9, 0xE1, 0x0F, 0x65, 0x85, 0x86, 0x2D, 0x7D, 0xD7, 0xDD, 0xA3, 0x8E, 0xE6, 0x7D, 0xDE, 0x7E, 0xAE, 0x0E,
    0x0F, 0xE1, 0x89, 0x7E, 0x23, 0x7D, 0xF5, 0x79, 0x23, 0xE1, 0x4B, 0x83, 0x0C, 0x0F, 0x85, 0x7B, 0x85, 0x7E, 0x8F, 0x80, 0x85, 0x98, 0xF5, 0x7A, 0x85, 0x1A, 0x0D, 0xE1, 0x0F, 0x7C, 0x89, 0x0C,
    0x85, 0x0B, 0x23, 0x69, 0x87, 0x7B, 0x23, 0x0C, 0x1F, 0xB7, 0x21, 0x7A, 0x88, 0x7E, 0x8F, 0xA5, 0x7D, 0x80, 0xB7, 0xB9, 0x18, 0xBF, 0x4B, 0x19, 0x85, 0xA5, 0x91, 0x80, 0x87, 0x81, 0x87, 0x7C,
    0x0F, 0x73, 0x91, 0x91, 0x84, 0x87, 0x37, 0xD7, 0x86, 0x79, 0xE1, 0xDD, 0x85, 0x7A, 0x73, 0x9B, 0x05, 0x7D, 0x0D, 0x83, 0x87, 0x9C, 0x85, 0x33, 0x87, 0x7D, 0x85, 0x0F, 0x87, 0x7D, 0x0D, 0x7D,
    0xF6, 0x7E, 0x87, 0x7D, 0x88, 0x19, 0x89, 0xF5, 0xD1, 0xDD, 0x85, 0x7D, 0x8B, 0xC3, 0xEA, 0x7A, 0xD7, 0xB0, 0x0D, 0x7D, 0x87, 0xA5, 0x87, 0x7C, 0x73, 0x7E, 0x7D, 0x86, 0x87, 0x23, 0x85, 0x10,
    0xD7, 0xDF, 0xED, 0xA5, 0xE1, 0x7A, 0x85, 0x23, 0xEA, 0x7E, 0x85, 0x98, 0xAD, 0x79, 0x86, 0x7D, 0x85, 0x7D, 0xD7, 0x7D, 0xE1, 0x7A, 0xF5, 0x7D, 0x85, 0xB0, 0x2B, 0x37, 0xE1, 0x7A, 0x87, 0x79,
    0x84, 0x7D, 0x73, 0x73, 0x87, 0x7D, 0x23, 0x7D, 0xE9, 0x7D, 0x85, 0x7E, 0x02, 0x7D, 0xDD, 0x2D, 0x87, 0x79, 0xE7, 0x79, 0xAD, 0x7C, 0x23, 0xDA, 0x87, 0x0D, 0x0D, 0x7B, 0xE7, 0x79, 0x9B, 0x7D,
    0xD7, 0x8F, 0x05, 0x7D, 0x0D, 0x34, 0x8F, 0x7D, 0xAD, 0x87, 0xE9, 0x7C, 0x85, 0x80, 0x85, 0x79, 0x8A, 0xC3, 0xE7, 0xA5, 0xE8, 0x6B, 0x0D, 0x74, 0x10, 0x73, 0x33, 0x17, 0x0D, 0x37, 0x21, 0x19   
            #endregion
        };

        private static byte[] _hashTable;
        public static byte[] HashTable
        {
            get => _hashTable;
            set
            {
                if (value.Length != 16)
                    throw new InvalidOperationException();

                _hashTable = value;
                HashIncrement = 0;
            }
        }

        public static int HashIncrement { get; private set; } = -1;

        /// <summary>
        /// Decrypts the packet data.
        /// </summary>
        /// <param name="pBuffer">Pointer to the packet buffer.</param>
        /// <param name="offset">Offset where the packet starts in the buffer.</param>
        /// <returns>If the decryption succeeds.</returns>
        public static unsafe bool Decrypt(byte[] pBuffer, int offset = 0)
        {
            fixed (byte* pBufferPin = pBuffer)
            {
                uint keyIncrement = KeyTable[(pBufferPin[2 + offset] * 2)];
                uint keyResult = 0;
                byte checksumEnc = 0;
                byte checksumDec = 0;
                bool sucessfull = true;

                for (int i = 4, thisIterator = 0; i < *(ushort*)&pBufferPin[offset]; i++, keyIncrement++)
                {
                    checksumEnc += pBufferPin[i + offset];

                    keyResult = KeyTable[((keyIncrement & 0x800000FF) * 2) + 1];

                    thisIterator = i & 3;

                    switch (thisIterator)
                    {
                        case 0:
                            pBufferPin[i + offset] -= (byte)(keyResult << 1);
                            break;

                        case 1:
                            pBufferPin[i + offset] += (byte)((int)(keyResult) >> 3);
                            break;

                        case 2:
                            pBufferPin[i + offset] -= (byte)(keyResult << 2);
                            break;

                        case 3:
                            pBufferPin[i + offset] += (byte)((int)keyResult >> 5);
                            break;
                    }

                    checksumDec += pBufferPin[i + offset];
                }

                // Do checksum
                if (pBufferPin[3 + offset] != (byte)(checksumEnc - checksumDec)) // Old checksum
                {
                    sucessfull = false;
                }

                return sucessfull;
            }
        }

        public static bool Decrypt(CCompoundBuffer buffer)
        {
            return Decrypt(buffer.RawBuffer, buffer.Offset);
        }

        public static Int32 LastPacket
        {
            set { m_LastPacket = value; }
        }

        public static Int32 TimePacket
        {
            set { m_TimePacket = value; }
        }

        public static Int32 GetTimeStamp()
        {
            return m_TimePacket + (Environment.TickCount - m_LastPacket);
        }

        /// <summary>
        /// Encrypts the packet data and initialize the packet header.
        /// </summary>
        /// <param name="pBuffer">Pointer to the packet buffer.</param>
        /// <param name="offset">Offset where the packet starts in the buffer.</param>
        public static unsafe void Encrypt(byte[] pBuffer)
        {
            UInt16 packetSize = BitConverter.ToUInt16(pBuffer, 0);

            if (pBuffer.Length < 12 || packetSize < 12)
                return;

            Byte checksumEnc = 0;
            Byte checksumDec = 0;
            Byte keyResult = 0;
            Byte hashKey = pBuffer[2];

            UInt32 keyIncrement = (UInt32)(KeyTable[hashKey * 2] & 0xFF);

            for (UInt16 offset = 4; offset < packetSize; offset++, keyIncrement++)
            {
                checksumDec += pBuffer[offset];

                keyResult = KeyTable[((keyIncrement & 0x800000FF) * 2) + 1];

                switch (offset & 3)
                {
                    case 00:
                        pBuffer[offset] += (Byte)(keyResult * 2);
                        break;

                    case 01:
                        pBuffer[offset] -= (Byte)(keyResult >> 3);
                        break;

                    case 02:
                        pBuffer[offset] += (Byte)(keyResult * 4);
                        break;

                    case 03:
                        pBuffer[offset] -= (Byte)(keyResult >> 5);
                        break;
                }

                checksumEnc += pBuffer[offset];
            }

            pBuffer[3] = (Byte)(checksumEnc - checksumDec);
        }

        public static Byte GetHashByte()
        {
            Byte hash = 0;

            if (HashTable != null && HashTable[0] != 0)
            {
                if (HashIncrement <= 15)
                {
                    hash = (Byte)(HashTable[HashIncrement] ^ 0xFF);
                    ++HashIncrement;
                }
                else
                {
                    switch (HashTable[15] & 0x80000001)
                    {
                        case 00:
                            hash = (Byte)(((HashTable[1] + HashTable[3]) + HashTable[5]) - 87);
                            break;
                        case 01:
                            hash = (Byte)(((HashTable[13] + HashTable[11]) - HashTable[9]) + 4);
                            break;
                    }

                    hash ^= 0xFF;
                }
            }

            return hash;
        }
    }
}